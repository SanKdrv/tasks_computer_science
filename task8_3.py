# Можно
# решить
# данную
# задачу
# с
# помощью
# динамического
# программирования.Необходимо
# отсортировать
# массив
# pairs
# по
# возрастанию
# правых
# элементов, чтобы
# обеспечить
# возможность
# перехода
# только
# вперед.Затем
# можно
# использовать
# классический
# алгоритм
# нахождения
# наибольшей
# возрастающей
# подпоследовательности.
#
# В
# данном
# случае, вместо
# чисел, мы
# будем
# работать
# с
# парами.Для
# каждой
# пары
# i
# будем
# хранить
# длину
# наибольшей
# последовательности, заканчивающейся
# на
# этой
# паре.Изначально
# для
# каждой
# пары
# длина
# равна
# 1.
# Затем
# для
# каждой
# пары
# i
# будем
# перебирать
# все
# предыдущие
# пары
# j
# и, если
# j < i
# и
# правый
# элемент
# j
# меньше
# левого
# элемента
# i, то
# можно
# обновить
# значение
# длины
# последовательности
# для
# i: dp[i] = max(dp[i], dp[j] + 1).
#
# В
# конце
# необходимо
# найти
# максимальное
# значение
# в
# массиве
# dp
# и
# вернуть
# его.
#
# Реализация:
#
# python


def max_sequence_length(pairs):
    # Сортируем массив pairs по возрастанию правых элементов
    pairs.sort(key=lambda x: x[1])

    n = len(pairs)
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if pairs[j][1] < pairs[i][0]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)


# Примеры
# использования:
#
# python
# >> > max_sequence_length([[1, 2], [2, 3], [3, 4]])
# 2
#
# >> > max_sequence_length([[1, 2], [7, 8], [4, 5]])
# 3